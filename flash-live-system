#!/usr/bin/env bash
set -euo pipefail

_require() {
  for cmd in "$@"; do
    if ! command -v "$cmd" &>/dev/null; then
      echo "Error: required command '$cmd' not found" >&2
      return 1
    fi
  done
}

# --- BEGIN _extract_busybox ---
_extract_busybox() {
  # Source version stub. ./run build replaces this with the real binary.
  # The built version uses `base64 -d` (coreutils) — a bootstrap dependency
  # needed before busybox itself is available.
  echo "Error: this is the source version of flash-live-system." >&2
  echo "Run './run build' to produce a release artifact, or download from GitHub Releases." >&2
  return 1
}
# --- END _extract_busybox ---

# --- Config file parser ---

parse_config() {
  local config_file="$1"
  if [ ! -f "$config_file" ]; then
    echo "Error: config file not found: $config_file" >&2
    exit 1
  fi
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip blank lines and comments
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    key="${line%%=*}"
    value="${line#*=}"
    # Trim whitespace from key
    key=$(echo "$key" | tr -d '[:space:]')
    # Expand leading ~/ to $HOME/ (shell doesn't expand tildes in file content)
    value="${value/#\~\//$HOME/}"
    case "$key" in
      hostname)      custom_hostname="$value" ;;
      user)          custom_user="$value" ;;
      password)      custom_password="$value" ;;
      ssh-key)       custom_ssh_keys+=("$value") ;;
      wifi-ssid)     wifi_ssid="$value" ;;
      wifi-password) wifi_password="$value" ;;
      wifi-country)  wifi_country="$value" ;;
      *)
        echo "Error: unknown config key '$key' in $config_file" >&2
        exit 1
        ;;
    esac
  done < "$config_file"
}

# --- Argument parsing ---

mode="ramfs"
mode_explicit=false
remote_host=""
margin_bytes=209715200  # 200 MB safety margin for /dev/shm checks
custom_hostname=""
custom_user=""
custom_password=""
custom_ssh_keys=()
wifi_ssid=""
wifi_password=""
wifi_country="GB"
skip_confirm=false
skip_confirm_yes=false
skip_confirm_really=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --ramfs)  mode="ramfs";  mode_explicit=true; shift ;;
    --stream) mode="stream"; mode_explicit=true; shift ;;
    --remote)
      if [ $# -lt 2 ]; then
        echo "Error: --remote requires a host argument" >&2
        exit 1
      fi
      remote_host="$2"; shift 2 ;;
    --config)
      if [ $# -lt 2 ]; then
        echo "Error: --config requires a file path" >&2
        exit 1
      fi
      parse_config "$2"; shift 2 ;;
    --yes) skip_confirm_yes=true; shift ;;
    --yes-i-really-mean-it) skip_confirm_really=true; shift ;;
    -*)
      echo "Error: unknown option '$1'" >&2
      echo "" >&2
      echo "Usage: flash-live-system [--remote <host>] [--ramfs|--stream] [--config FILE] [--yes --yes-i-really-mean-it] <image>" >&2
      exit 1
      ;;
    *) break ;;
  esac
done

# Validate --yes / --yes-i-really-mean-it flags
if $skip_confirm_yes && $skip_confirm_really; then
  skip_confirm=true
elif $skip_confirm_yes; then
  echo "Error: --yes alone is not enough. You must also pass --yes-i-really-mean-it to skip confirmation." >&2
  exit 1
elif $skip_confirm_really; then
  echo "Error: --yes-i-really-mean-it requires --yes as well." >&2
  exit 1
fi

if [ $# -lt 1 ]; then
  echo "Usage: flash-live-system [--remote <host>] [--ramfs|--stream] [--config FILE] [--yes --yes-i-really-mean-it] <image>" >&2
  echo "" >&2
  echo "Flash an image to a Linux device, either locally or remotely over SSH." >&2
  echo "" >&2
  echo "Options:" >&2
  echo "  --remote <host>    Flash a remote device over SSH (default: flash locally)" >&2
  echo "  --ramfs            Force ramfs mode: copy image to /dev/shm, then decompress+dd" >&2
  echo "  --stream           Stream image directly (over SSH, or from another disk locally)" >&2
  echo "  --config FILE      Config file with key=value settings for first-boot customization." >&2
  echo "                     See example.conf for available keys and format." >&2
  echo "  --yes --yes-i-really-mean-it" >&2
  echo "                     Skip the interactive confirmation prompt (both flags required)." >&2
  echo "" >&2
  echo "In local mode (default), auto-detects ramfs vs stream based on /dev/shm space" >&2
  echo "and disk layout. Must be run as root." >&2
  echo "" >&2
  echo "Supported formats: .img, .img.xz, .img.gz" >&2
  echo "" >&2
  echo "Examples (local — default):" >&2
  echo "  sudo flash-live-system image.img.xz" >&2
  echo "  sudo flash-live-system --config myboat.conf image.img.xz" >&2
  echo "  sudo flash-live-system --ramfs image.img.xz" >&2
  echo "  sudo flash-live-system --stream /mnt/usb/image.img.xz" >&2
  echo "" >&2
  echo "Examples (remote):" >&2
  echo "  flash-live-system --remote halos.local image.img.xz" >&2
  echo "  flash-live-system --remote pi@192.168.1.100 --config myboat.conf image.img.xz" >&2
  echo "  flash-live-system --remote halos.local --stream image.img" >&2
  echo "" >&2
  echo "Prerequisites:" >&2
  echo "  Local:  root access" >&2
  echo "  Remote: ssh, scp" >&2
  exit 1
fi

image="$1"

# Validate image file exists
if [ ! -f "$image" ]; then
  echo "Error: image file not found: $image" >&2
  exit 1
fi

# Determine decompression command based on format
decompress_cmd=""
case "$image" in
  *.img.xz) decompress_cmd="xzcat" ;;
  *.img.gz) decompress_cmd="zcat" ;;
  *.img)    decompress_cmd="cat" ;;
  *)
    echo "Error: unsupported image format (expected .img, .img.xz, or .img.gz)" >&2
    exit 1
    ;;
esac

# Fixed /dev/shm staging filename avoids shell metacharacter issues.
# The extension is preserved so the helper knows how to decompress.
case "$image" in
  *.img.xz) shm_image="/dev/shm/flash-image.img.xz" ;;
  *.img.gz) shm_image="/dev/shm/flash-image.img.gz" ;;
  *.img)    shm_image="/dev/shm/flash-image.img" ;;
esac

# Get compressed (on-disk) file size
image_size=$(stat -f%z "$image" 2>/dev/null || stat -c%s "$image" 2>/dev/null || true)
if [ -z "$image_size" ]; then
  echo "Error: could not determine image file size" >&2
  exit 1
fi
image_size_mb=$((image_size / 1048576))

size_label="on-disk"
if [[ "$image" == *.img.xz ]] || [[ "$image" == *.img.gz ]]; then
  size_label="compressed"
fi

# --- Validate customization flags ---

if [ -n "$custom_hostname" ] && ! [[ "$custom_hostname" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$ ]]; then
  echo "Error: hostname must contain only alphanumeric characters and hyphens" >&2
  exit 1
fi
if [ -n "$custom_user" ] && ! [[ "$custom_user" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
  echo "Error: username must be a valid Linux username (lowercase, alphanumeric, hyphens, underscores)" >&2
  exit 1
fi
if [ -n "$wifi_country" ] && ! [[ "$wifi_country" =~ ^[A-Z]{2}$ ]]; then
  echo "Error: wifi-country must be a 2-letter country code (e.g., GB, US, FI)" >&2
  exit 1
fi
if [ -n "$wifi_ssid" ] && [ -z "$wifi_password" ]; then
  echo "Error: wifi-ssid requires wifi-password" >&2
  exit 1
fi
if [ -n "$wifi_password" ] && [ -z "$wifi_ssid" ]; then
  echo "Error: wifi-password requires wifi-ssid" >&2
  exit 1
fi
if [ -n "$custom_password" ] && [ -z "$custom_user" ]; then
  echo "Error: password requires user" >&2
  exit 1
fi

# If user given without explicit ssh-key, auto-detect local SSH public keys
if [ -n "$custom_user" ] && [ ${#custom_ssh_keys[@]} -eq 0 ]; then
  for pubkey in ~/.ssh/*.pub; do
    [ -f "$pubkey" ] && custom_ssh_keys+=("$pubkey")
  done
fi

if [ -n "$custom_user" ] && [ -z "$custom_password" ] && [ ${#custom_ssh_keys[@]} -eq 0 ]; then
  echo "Warning: user set but no password or SSH keys found. User will have no authentication method." >&2
  echo "  Add password or ssh-key to your config file, or place public keys in ~/.ssh/*.pub" >&2
fi

# If password given, hash it locally
password_hash=""
if [ -n "$custom_password" ]; then
  _require openssl
  password_hash=$(printf '%s' "$custom_password" | openssl passwd -6 -stdin)
fi

has_customization=false
if [ -n "$custom_hostname" ] || [ -n "$custom_user" ] || [ -n "$wifi_ssid" ]; then
  has_customization=true
fi

# --- Generate first-boot payloads ---
# Follows the cloudinit-rpi format used by RPi Imager 2.x:
# - user-data: cloud-init YAML with users: block, hostname, ssh_pwauth
# - network-config: netplan YAML with eth0 + optional wlan0

custom_user_data=""
custom_network_config=""

# Build user-data YAML matching RPi Imager's cloudinit-rpi format
ud_lines=()
ud_lines+=("#cloud-config")

if [ -n "$custom_hostname" ]; then
  ud_lines+=("hostname: $custom_hostname")
  ud_lines+=("manage_etc_hosts: true")
fi

if [ -n "$custom_user" ]; then
  # Read SSH public keys
  ssh_key_lines=()
  for keyfile in "${custom_ssh_keys[@]}"; do
    if [ ! -f "$keyfile" ]; then
      echo "Error: SSH key file not found: $keyfile" >&2
      exit 1
    fi
    ssh_key_lines+=("$(head -1 "$keyfile")")
  done

  ud_lines+=("users:")
  ud_lines+=("  - name: $custom_user")
  ud_lines+=("    groups: users,adm,dialout,audio,netdev,video,plugdev,cdrom,games,input,gpio,spi,i2c,render,sudo")
  ud_lines+=("    shell: /bin/bash")
  ud_lines+=("    sudo: ALL=(ALL) NOPASSWD:ALL")
  if [ -n "$password_hash" ]; then
    ud_lines+=("    lock_passwd: false")
    ud_lines+=("    passwd: $password_hash")
  fi
  if [ ${#ssh_key_lines[@]} -gt 0 ]; then
    ud_lines+=("    ssh_authorized_keys:")
    for key in "${ssh_key_lines[@]}"; do
      ud_lines+=("      - $key")
    done
  fi
  ud_lines+=("enable_ssh: true")
  ud_lines+=("ssh_pwauth: true")
fi

# Only produce user-data if there's more than just the #cloud-config header
if [ ${#ud_lines[@]} -gt 1 ]; then
  custom_user_data=$(printf '%s\n' "${ud_lines[@]}")
  # NoCloud datasource requires meta-data to exist (even if minimal)
  custom_meta_data="instance-id: flash-live-system-$(date +%s)"
fi

if [ -n "$wifi_ssid" ]; then
  # Compute WPA PSK from passphrase + SSID (avoids plaintext password on disk)
  _require python3
  wifi_psk=$(python3 -c "
import hashlib, sys
psk = hashlib.pbkdf2_hmac('sha1', sys.argv[1].encode(), sys.argv[2].encode(), 4096, 32)
print(psk.hex())
" "$wifi_password" "$wifi_ssid")

  # Match RPi Imager's network-config format exactly
  custom_network_config="network:
  version: 2
  ethernets:
    eth0:
      dhcp4: true
      dhcp6: true
      optional: true
  wifis:
    wlan0:
      dhcp4: true
      regulatory-domain: \"$wifi_country\"
      access-points:
        \"$wifi_ssid\":
          password: \"$wifi_psk\"
      optional: true"
fi

# Mode-specific prerequisites
if [ -z "$remote_host" ]; then
  if [ "$(uname -s)" != "Linux" ]; then
    echo "Error: local mode requires Linux (detected $(uname -s))" >&2
    exit 1
  fi
  if [ "$(id -u)" -ne 0 ]; then
    echo "Error: local mode must be run as root (use sudo)" >&2
    exit 1
  fi
  if [ "$(uname -m)" != "aarch64" ]; then
    echo "Error: local architecture is $(uname -m) (expected aarch64)" >&2
    exit 1
  fi
else
  _require ssh scp
  ssh_err=$(ssh -n -o BatchMode=yes -o ConnectTimeout=10 "$remote_host" true 2>&1) || {
    echo "Error: cannot connect to $remote_host via SSH" >&2
    [ -n "$ssh_err" ] && echo "  $ssh_err" >&2
    exit 1
  }
  if [ "$mode" = "stream" ]; then
    _require "$decompress_cmd"
  fi
fi

# --- image_on_same_disk: check if image file resides on the target disk ---
# Returns 0 (true) if the image is on the same block device as $root_dev.
# For non-block sources (NFS, tmpfs, FUSE), lsblk returns empty and this
# correctly returns 1 (false) — streaming from those sources is safe.
image_on_same_disk() {
  local img_mount img_parent
  img_mount=$(findmnt -no SOURCE --target "$image")
  if [ -n "$img_mount" ]; then
    img_parent=$(lsblk -ndo PKNAME "$img_mount" 2>/dev/null || true)
    if [ -n "$img_parent" ] && [ "/dev/$img_parent" = "$root_dev" ]; then
      return 0
    fi
  fi
  return 1
}

# --- run_on_target: execute a command locally or via SSH ---

run_on_target() {
  if [ -z "$remote_host" ]; then
    bash -c "$1"
  else
    ssh -n "$remote_host" "$1"
  fi
}

# Pipe stdin to a command on the target (for payload transfer)
pipe_to_target() {
  if [ -z "$remote_host" ]; then
    bash -c "$1"
  else
    # shellcheck disable=SC2029  # $1 is intentionally expanded client-side
    ssh "$remote_host" "$1"
  fi
}

check_target_device() {
  local arch model

  arch=$(run_on_target "uname -m")
  if [ "$arch" != "aarch64" ]; then
    echo "Error: target architecture is $arch (expected aarch64)" >&2
    exit 1
  fi

  model=$(run_on_target "cat /sys/firmware/devicetree/base/model 2>/dev/null | tr -d '\0'" 2>/dev/null || echo "")
  if [ -n "$model" ]; then
    echo "Target device: $model"
    if ! echo "$model" | grep -qi "raspberry pi"; then
      echo "Note: this is not a Raspberry Pi — verify the image is compatible"
    fi
  fi
}

target_label() {
  if [ -z "$remote_host" ]; then
    echo "local device"
  else
    echo "$remote_host"
  fi
}

# --- Phase 0: Resolve hostname and detect target device ---

echo "=== Phase 0: Detecting target device ==="

# Detect root block device
root_part=$(run_on_target "findmnt -no SOURCE /")
if [ -z "$root_part" ]; then
  echo "Error: could not detect root partition" >&2
  exit 1
fi

root_dev=$(run_on_target "lsblk -ndo PKNAME '$root_part'")
if [ -z "$root_dev" ]; then
  echo "Error: could not determine parent device for $root_part" >&2
  exit 1
fi
root_dev="/dev/$root_dev"

if ! run_on_target "test -b '$root_dev'"; then
  echo "Error: $root_dev is not a valid block device on $(target_label)" >&2
  exit 1
fi

check_target_device

dev_size=$(run_on_target "lsblk -bno SIZE '$root_dev' | head -1")
dev_size_gb=$((dev_size / 1073741824))

# Auto-detect flash mode for local when not explicitly set
if [ -z "$remote_host" ] && [ "$mode_explicit" = false ]; then
  shm_avail=$(run_on_target "df -B1 --output=avail /dev/shm | tail -1 | tr -d ' '")
  required=$((image_size + margin_bytes))
  if [ "$shm_avail" -ge "$required" ]; then
    mode="ramfs"
    echo "Auto-selected ramfs mode (/dev/shm has sufficient space)"
  else
    # Not enough shm — check if image is on a different disk than the target
    if image_on_same_disk; then
      echo "Error: insufficient /dev/shm space and image is on the target disk ($root_dev)" >&2
      echo "  /dev/shm available: $((shm_avail / 1048576)) MB, required: $((required / 1048576)) MB" >&2
      echo "  Cannot flash safely. Move the image to a USB drive or free up RAM." >&2
      exit 1
    fi
    mode="stream"
    echo "Auto-selected stream mode (insufficient /dev/shm, image on separate disk)"
  fi
fi

# Mode-specific preflight checks
if [ "$mode" = "ramfs" ]; then
  # Check /dev/shm capacity (trim whitespace from df output)
  shm_avail=$(run_on_target "df -B1 --output=avail /dev/shm | tail -1 | tr -d ' '")
  shm_avail_mb=$((shm_avail / 1048576))
  required=$((image_size + margin_bytes))
  if [ "$shm_avail" -lt "$required" ]; then
    echo "Error: insufficient space in /dev/shm on target" >&2
    echo "  Available: ${shm_avail_mb} MB" >&2
    echo "  Required:  $((required / 1048576)) MB (image + 200 MB margin)" >&2
    echo "" >&2
    echo "Try --stream mode for low-memory devices." >&2
    exit 1
  fi
  echo "Target /dev/shm: ${shm_avail_mb} MB available (need ${image_size_mb} MB + margin)"
fi

# Preflight checks for customization capabilities on target
if [ "$has_customization" = true ]; then
  echo "Checking customization prerequisites on target..."

  # Verify kernel supports vfat
  if ! run_on_target "grep -q vfat /proc/filesystems"; then
    echo "Error: kernel on $(target_label) lacks vfat support (required for customization)" >&2
    exit 1
  fi
fi

# --- Confirmation prompt ---

echo ""
if [ -z "$remote_host" ]; then
  echo "  Mode: local $mode"
else
  echo "  Mode: remote $mode"
fi
echo "  Target device: $root_dev (~${dev_size_gb} GB)"
echo "  Root partition: $root_part"
echo "  Image file: $image (${image_size_mb} MB ${size_label})"
if [ -n "$remote_host" ]; then
  echo "  Target host: $remote_host"
fi
if [ "$has_customization" = true ]; then
  echo ""
  echo "  First-boot customization:"
  [ -n "$custom_hostname" ] && echo "    Hostname: $custom_hostname"
  if [ -n "$custom_user" ]; then
    user_info="$custom_user"
    [ -n "$custom_password" ] && user_info+=" (with password)"
    [ ${#custom_ssh_keys[@]} -gt 0 ] && user_info+=" (with ${#custom_ssh_keys[@]} SSH key(s))"
    echo "    User: $user_info"
  fi
  [ -n "$wifi_ssid" ] && echo "    WiFi: $wifi_ssid (country: $wifi_country)"
fi
echo ""
if [ -z "$remote_host" ]; then
  echo "WARNING: This will ERASE ALL DATA on $root_dev."
  echo "The device will reboot when flashing is done."
else
  echo "WARNING: This will ERASE ALL DATA on $root_dev on $remote_host."
  echo "The device will be unreachable during flashing and will reboot when done."
fi
echo ""
if $skip_confirm; then
  echo "Skipping confirmation (--yes --yes-i-really-mean-it)."
else
  if [ -z "$remote_host" ]; then
    nuke_target="localhost"
  else
    nuke_target="$remote_host"
  fi
  confirm_phrase="nuke $nuke_target from orbit"
  read -r -p "Type \"$confirm_phrase\" to proceed: " confirm
  if [ "$confirm" != "$confirm_phrase" ]; then
    echo "Aborted."
    exit 1
  fi
fi

# Deploy embedded busybox to target
echo ""
echo "Deploying embedded busybox to target..."
if [ -z "$remote_host" ]; then
  _extract_busybox /dev/shm/busybox
else
  _bb_tmp="/tmp/flash-busybox-$$"
  # Clean up temp file on failure (set -e would skip the rm)
  _extract_busybox "$_bb_tmp" || { rm -f "$_bb_tmp"; exit 1; }
  scp -O "$_bb_tmp" "$remote_host:/dev/shm/busybox" || { rm -f "$_bb_tmp"; exit 1; }
  rm -f "$_bb_tmp"
fi
run_on_target "chmod +x /dev/shm/busybox"
# Sanity check: catch truncated/corrupted binary before we get confusing errors later
run_on_target "/dev/shm/busybox --help >/dev/null 2>&1" \
  || { echo "Error: deployed busybox binary is not executable (truncated or corrupted?)" >&2; exit 1; }

# Transfer customization payloads to target (after confirmation to avoid
# leaving sensitive data on target if the user aborts)
if [ "$has_customization" = true ]; then
  echo ""
  echo "Transferring customization payloads..."
  if [ -n "$custom_user_data" ]; then
    echo "$custom_user_data" | pipe_to_target "cat > /dev/shm/custom-user-data"
    echo "$custom_meta_data" | pipe_to_target "cat > /dev/shm/custom-meta-data"
  fi
  if [ -n "$custom_network_config" ]; then
    echo "$custom_network_config" | pipe_to_target "cat > /dev/shm/custom-network-config"
    echo "$wifi_country" | pipe_to_target "cat > /dev/shm/custom-wifi-country"
  fi

  # Deploy shared customization script to /dev/shm. Called by all flash modes
  # after dd completes. Expects $BUSYBOX and $TARGET_DEV set by the caller.
  #
  # NO shebang — this script is sourced (`. /dev/shm/apply-customization.sh`),
  # not executed. After dd overwrites the rootfs, the kernel cannot exec
  # /bin/bash from the destroyed disk. Sourcing reads the file from tmpfs
  # into the already-running bash process — no disk access needed.
  pipe_to_target "cat > /dev/shm/apply-customization.sh" <<'CUSTOMIZATION_EOF'
# Sourced script — no shebang. Expects $BUSYBOX and $TARGET_DEV from caller.

if [ ! -f /dev/shm/custom-user-data ] && [ ! -f /dev/shm/custom-network-config ]; then
  return 0
fi

echo "apply-customization: applying first-boot customization..."

# Mount via loop device at the correct offset from the NEW partition table.
# After dd, the kernel still has stale partition nodes (old offsets/sizes)
# and stale block cache from the old image. Using the partition node would
# read/write at the wrong offset or serve cached data. Instead, parse the
# new partition table directly and create a loop device at the right offset.
#
# Busybox fdisk format (CHS columns precede LBA):
#   /dev/nvme0n1p1 *  128,0,1  1023,3,32  16384  1064959  1048576  512M c ...
# After stripping the optional boot flag (*), StartLBA is field 4.
PART1_LINE=$("$BUSYBOX" fdisk -l "$TARGET_DEV" 2>/dev/null \
  | "$BUSYBOX" grep "^${TARGET_DEV}" | "$BUSYBOX" head -1)
PART1_START=$(echo "$PART1_LINE" | "$BUSYBOX" sed 's/\*//' | "$BUSYBOX" awk '{print $4}')

# Validate parsed offset — must be a positive integer
if ! echo "$PART1_START" | "$BUSYBOX" grep -qE '^[0-9]+$' || [ "$PART1_START" -eq 0 ]; then
  echo "apply-customization: ERROR: failed to parse boot partition offset (got: '$PART1_START')"
  return 1
fi
OFFSET=$((PART1_START * 512))

LOOP_DEV=$("$BUSYBOX" losetup -f)
"$BUSYBOX" losetup -o "$OFFSET" "$LOOP_DEV" "$TARGET_DEV"

"$BUSYBOX" mkdir -p /dev/shm/bootmnt
if "$BUSYBOX" mount -t vfat "$LOOP_DEV" /dev/shm/bootmnt; then
  [ -f /dev/shm/custom-user-data ] && \
    "$BUSYBOX" cp /dev/shm/custom-user-data /dev/shm/bootmnt/user-data
  [ -f /dev/shm/custom-meta-data ] && \
    "$BUSYBOX" cp /dev/shm/custom-meta-data /dev/shm/bootmnt/meta-data
  [ -f /dev/shm/custom-network-config ] && \
    "$BUSYBOX" cp /dev/shm/custom-network-config /dev/shm/bootmnt/network-config
  # Update regulatory domain in cmdline.txt to match WiFi country
  if [ -f /dev/shm/custom-wifi-country ] && [ -f /dev/shm/bootmnt/cmdline.txt ]; then
    REGDOM=$("$BUSYBOX" cat /dev/shm/custom-wifi-country | "$BUSYBOX" tr -d '[:space:]')
    "$BUSYBOX" sed -i "s/cfg80211.ieee80211_regdom=[A-Z]*/cfg80211.ieee80211_regdom=$REGDOM/" /dev/shm/bootmnt/cmdline.txt
  fi
  # umount flushes FAT32 data. No explicit sync — a global sync would risk
  # writing back old rootfs dirty pages over the new image.
  "$BUSYBOX" umount /dev/shm/bootmnt
  echo "apply-customization: boot partition customization applied"
else
  echo "apply-customization: ERROR: could not mount boot partition for customization"
fi
"$BUSYBOX" losetup -d "$LOOP_DEV" 2>/dev/null || true
CUSTOMIZATION_EOF
fi

# --- Ramfs helper deployment (shared by remote and local ramfs modes) ---

deploy_ramfs_helper() {
  # Deploy helper script to /dev/shm on the target. The helper decompresses
  # the image from /dev/shm, writes it to the block device, applies
  # customization, and reboots. All variable values are passed as arguments
  # to avoid shell metacharacter issues.
  #
  # The embedded busybox is already deployed to /dev/shm/busybox before this
  # function is called. No binary copies needed — busybox provides all applets.
  pipe_to_target "cat > /dev/shm/flash-helper.sh && chmod +x /dev/shm/flash-helper.sh" <<'HELPER_EOF'
#!/bin/bash

# Phase 1 — runs under /bin/bash from rootfs (safe: dd hasn't started yet).
# Re-exec under busybox sh from tmpfs so that NOTHING running after dd
# depends on rootfs pages. Busybox is already on /dev/shm (deployed by
# the host script before transfer).

if [ -z "$_FLASH_REEXEC" ]; then
  export _FLASH_REEXEC=1
  exec /dev/shm/busybox sh "$0" "$@"
fi

# Phase 2 — runs under busybox sh from tmpfs. No rootfs dependencies.
set -eo pipefail

IMAGE_PATH="$1"
TARGET_DEV="$2"
DECOMPRESS_CMD="$3"
BUSYBOX=/dev/shm/busybox

trap '"$BUSYBOX" reboot -f 2>/dev/null || { echo 1 > /proc/sys/kernel/sysrq; echo b > /proc/sysrq-trigger; }' EXIT

echo "flash-helper: decompressing and writing $IMAGE_PATH -> $TARGET_DEV"
"$BUSYBOX" "$DECOMPRESS_CMD" "$IMAGE_PATH" | "$BUSYBOX" dd of="$TARGET_DEV" bs=4M 2>/dev/shm/dd-status
echo "flash-helper: dd complete:"
"$BUSYBOX" cat /dev/shm/dd-status 2>/dev/null || true

"$BUSYBOX" rm -f "$IMAGE_PATH"

# Apply first-boot customization. Sourced (not executed) so no exec needed.
if [ -f /dev/shm/apply-customization.sh ]; then
  ( . /dev/shm/apply-customization.sh ) \
    || echo "flash-helper: WARNING: customization failed, continuing to reboot"
fi

# EXIT trap handles reboot -f (skips sync so old rootfs cache doesn't
# write back over the new image).
echo "flash-helper: rebooting..."
HELPER_EOF
}

# --- Ramfs mode ---

flash_ramfs() {
  echo ""
  echo "=== Phase 1: Copying image to target ==="

  echo "Copying image to /dev/shm on target..."
  scp -O "$image" "$remote_host:$shm_image"

  # Verify file size matches
  remote_size=$(ssh -n "$remote_host" "stat -c%s '$shm_image'")
  if [ "$remote_size" != "$image_size" ]; then
    echo "Error: size mismatch after transfer" >&2
    echo "  Local:  $image_size bytes" >&2
    echo "  Remote: $remote_size bytes" >&2
    echo "Cleaning up remote file..."
    ssh -n "$remote_host" "rm -f '$shm_image'"
    exit 1
  fi
  echo "Transfer verified: $remote_size bytes"

  echo ""
  echo "=== Phase 2: Flashing image ==="

  echo "Stopping services on target..."
  ssh -n "$remote_host" "sudo systemctl stop 'container-*' 'marine-*' 'halos-*' cockpit docker 2>/dev/null || true; sync"

  deploy_ramfs_helper

  echo "Launching flash helper on target..."
  ssh -n "$remote_host" "sudo setsid /dev/shm/flash-helper.sh '$shm_image' '$root_dev' '$decompress_cmd' </dev/null >/dev/shm/flash-helper.log 2>&1 &"

  echo ""
  echo "Image is being flashed on the target device."
  echo "The device will reboot automatically when done."
  echo ""
  echo "Wait ~60s then try: ssh $remote_host"
}

# --- Stream mode ---

flash_stream() {
  echo ""
  echo "=== Phase 1: Preparing target ==="

  # Deploy helper script — reads image data from stdin (piped via SSH),
  # writes to block device, then reboots. Busybox is already on /dev/shm.
  ssh "$remote_host" "cat > /dev/shm/flash-helper.sh" <<'HELPER_EOF'
#!/bin/bash

# Phase 1 — runs under /bin/bash from rootfs (safe: dd hasn't started yet).
# Re-exec under busybox sh from tmpfs. Stream mode: stdin carries the image
# data, but re-exec preserves stdin (exec replaces process in-place).

if [ -z "$_FLASH_REEXEC" ]; then
  export _FLASH_REEXEC=1
  exec /dev/shm/busybox sh "$0" "$@"
fi

# Phase 2 — runs under busybox sh from tmpfs. No rootfs dependencies.
TARGET_DEV="$1"
BUSYBOX=/dev/shm/busybox

trap '"$BUSYBOX" reboot -f 2>/dev/null || { echo 1 > /proc/sys/kernel/sysrq; echo b > /proc/sysrq-trigger; }' EXIT

echo "flash-helper: writing stdin -> $TARGET_DEV"
"$BUSYBOX" dd of="$TARGET_DEV" bs=4M 2>/dev/shm/dd-status
"$BUSYBOX" cat /dev/shm/dd-status 2>/dev/null || true
echo "flash-helper: dd complete"

if [ -f /dev/shm/apply-customization.sh ]; then
  ( . /dev/shm/apply-customization.sh ) \
    || echo "flash-helper: WARNING: customization failed, continuing to reboot"
fi

echo "flash-helper: rebooting..."
HELPER_EOF

  ssh -n "$remote_host" "chmod +x /dev/shm/flash-helper.sh"

  echo "Stopping services on target..."
  ssh -n "$remote_host" "sudo systemctl stop 'container-*' 'marine-*' 'halos-*' cockpit docker 2>/dev/null || true; sync"

  echo ""
  echo "=== Phase 2: Streaming image ==="

  start_time=$(date +%s)

  echo "Streaming image via SSH..."
  # SSH connection drops when the target reboots after dd — that's expected.
  # Disable errexit to capture PIPESTATUS and distinguish decompression
  # failures (real error) from SSH connection drops (expected).
  set +eo pipefail
  # shellcheck disable=SC2029  # $root_dev is intentionally expanded client-side
  "$decompress_cmd" "$image" | ssh "$remote_host" "sudo /dev/shm/flash-helper.sh '$root_dev'"
  decompress_exit=${PIPESTATUS[0]}
  set -eo pipefail

  end_time=$(date +%s)
  elapsed_s=$((end_time - start_time))

  if [ "$decompress_exit" -ne 0 ]; then
    echo ""
    echo "Error: decompression failed (exit code $decompress_exit)." >&2
    echo "The target device may be in an inconsistent state." >&2
    exit 1
  fi

  echo ""
  echo "Transfer complete (${elapsed_s}s)."
  echo "The device will reboot automatically."
  echo ""
  echo "Wait ~60s then try: ssh $remote_host"
}

# --- Local ramfs mode ---
# Uses the same helper script as remote ramfs — the helper already runs on
# the target device. Only the transfer method (cp vs scp) and launch method
# (direct setsid vs ssh setsid) differ.

flash_local_ramfs() {
  echo ""
  echo "=== Phase 1: Copying image to /dev/shm ==="

  echo "Copying $image to $shm_image..."
  cp "$image" "$shm_image"

  # Verify file size matches
  local_copy_size=$(stat -c%s "$shm_image")
  if [ "$local_copy_size" != "$image_size" ]; then
    echo "Error: size mismatch after copy" >&2
    echo "  Original: $image_size bytes" >&2
    echo "  Copy:     $local_copy_size bytes" >&2
    echo "Cleaning up..."
    rm -f "$shm_image"
    exit 1
  fi
  echo "Copy verified: $local_copy_size bytes"

  echo ""
  echo "=== Phase 2: Flashing image ==="

  echo "Stopping services..."
  systemctl stop 'container-*' 'marine-*' 'halos-*' cockpit docker 2>/dev/null || true
  sync

  # Deploy the same helper script as remote ramfs
  deploy_ramfs_helper

  echo "Launching flash helper..."
  # Run in foreground — no SSH session to survive, and the user needs to see
  # that flashing is still in progress. The EXIT trap in the helper reboots.
  exec /dev/shm/flash-helper.sh "$shm_image" "$root_dev" "$decompress_cmd"
}

# --- Local stream mode ---

flash_local_stream() {
  echo ""
  echo "=== Phase 1: Safety checks ==="

  # Refuse to stream if the image resides on the same block device being flashed.
  # Streaming reads the image while dd overwrites the disk — if they're the same
  # device, the read will get corrupted data.
  if image_on_same_disk; then
    echo "Error: image file resides on the same block device being flashed ($root_dev)" >&2
    echo "  Use --ramfs mode to safely flash from the same disk." >&2
    exit 1
  fi
  echo "Image is on a different block device — safe to stream."

  echo "Stopping services..."
  systemctl stop 'container-*' 'marine-*' 'halos-*' cockpit docker 2>/dev/null || true
  sync

  # Busybox is already on /dev/shm (deployed before payload transfer).
  # Write helper script to tmpfs. This will be exec'd under busybox sh
  # so that NOTHING running during/after dd depends on rootfs pages.
  cat > /dev/shm/flash-local-stream.sh <<'LOCAL_STREAM_EOF'
set -eo pipefail

IMAGE="$1"
TARGET_DEV="$2"
DECOMPRESS_CMD="$3"
BUSYBOX=/dev/shm/busybox

trap '"$BUSYBOX" reboot -f 2>/dev/null || { echo 1 > /proc/sys/kernel/sysrq; echo b > /proc/sysrq-trigger; }' EXIT

echo "flash-helper: decompressing and writing $IMAGE -> $TARGET_DEV"
"$BUSYBOX" "$DECOMPRESS_CMD" "$IMAGE" | "$BUSYBOX" dd of="$TARGET_DEV" bs=4M 2>/dev/shm/dd-status
echo "flash-helper: dd complete:"
"$BUSYBOX" cat /dev/shm/dd-status 2>/dev/null || true

if [ -f /dev/shm/apply-customization.sh ]; then
  ( . /dev/shm/apply-customization.sh ) \
    || echo "flash-helper: WARNING: customization failed, continuing to reboot"
fi

echo "flash-helper: rebooting..."
LOCAL_STREAM_EOF

  echo ""
  echo "=== Phase 2: Streaming image ==="

  echo "Decompressing and writing to $root_dev..."
  exec /dev/shm/busybox sh /dev/shm/flash-local-stream.sh "$image" "$root_dev" "$decompress_cmd"
}

# --- Dispatch ---

if [ -z "$remote_host" ]; then
  case "$mode" in
    ramfs)  flash_local_ramfs ;;
    stream) flash_local_stream ;;
  esac
else
  case "$mode" in
    ramfs)  flash_ramfs ;;
    stream) flash_stream ;;
  esac
fi
