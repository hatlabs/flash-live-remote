#!/usr/bin/env bash
set -euo pipefail

_require() {
  for cmd in "$@"; do
    if ! command -v "$cmd" &>/dev/null; then
      echo "Error: required command '$cmd' not found" >&2
      return 1
    fi
  done
}

# --- Config file parser ---

parse_config() {
  local config_file="$1"
  if [ ! -f "$config_file" ]; then
    echo "Error: config file not found: $config_file" >&2
    exit 1
  fi
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip blank lines and comments
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    key="${line%%=*}"
    value="${line#*=}"
    # Trim whitespace from key
    key=$(echo "$key" | tr -d '[:space:]')
    # Expand leading ~/ to $HOME/ (shell doesn't expand tildes in file content)
    value="${value/#\~\//$HOME/}"
    case "$key" in
      hostname)      custom_hostname="$value" ;;
      user)          custom_user="$value" ;;
      password)      custom_password="$value" ;;
      ssh-key)       custom_ssh_keys+=("$value") ;;
      wifi-ssid)     wifi_ssid="$value" ;;
      wifi-password) wifi_password="$value" ;;
      wifi-country)  wifi_country="$value" ;;
      *)
        echo "Error: unknown config key '$key' in $config_file" >&2
        exit 1
        ;;
    esac
  done < "$config_file"
}

# --- Argument parsing ---

mode="ramfs"
custom_hostname=""
custom_user=""
custom_password=""
custom_ssh_keys=()
wifi_ssid=""
wifi_password=""
wifi_country="GB"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --ramfs)  mode="ramfs";  shift ;;
    --stream) mode="stream"; shift ;;
    --config)
      if [ $# -lt 2 ]; then
        echo "Error: --config requires a file path" >&2
        exit 1
      fi
      parse_config "$2"; shift 2 ;;
    -*)
      echo "Error: unknown option '$1'" >&2
      echo "" >&2
      echo "Usage: flash-live-remote [--ramfs|--stream] [--config FILE] <host> <image>" >&2
      exit 1
      ;;
    *) break ;;
  esac
done

if [ $# -lt 2 ]; then
  echo "Usage: flash-live-remote [--ramfs|--stream] [--config FILE] <host> <image>" >&2
  echo "" >&2
  echo "Flash an image to a remote Linux device over the network." >&2
  echo "The device must be running and accessible via SSH." >&2
  echo "" >&2
  echo "Modes:" >&2
  echo "  --ramfs            (default) scp image to /dev/shm, then decompress+dd locally" >&2
  echo "  --stream           Stream image directly over SSH (for low-memory devices)" >&2
  echo "" >&2
  echo "First-boot customization:" >&2
  echo "  --config FILE      Config file with key=value settings for first-boot customization." >&2
  echo "                     See example.conf for available keys and format." >&2
  echo "" >&2
  echo "Supported formats: .img, .img.xz, .img.gz" >&2
  echo "" >&2
  echo "Examples:" >&2
  echo "  flash-live-remote halos.local image.img.xz" >&2
  echo "  flash-live-remote --config myboat.conf halos.local image.img.xz" >&2
  echo "  flash-live-remote --stream pi@192.168.1.100 image.img" >&2
  echo "" >&2
  echo "Prerequisites:" >&2
  echo "  Local:  ssh, scp, xzcat/zcat (for compressed images)" >&2
  echo "  Target: busybox (with fdisk, losetup, mount, umount applets for customization)" >&2
  exit 1
fi

host="$1"
image="$2"

# Validate image file exists
if [ ! -f "$image" ]; then
  echo "Error: image file not found: $image" >&2
  exit 1
fi

# Determine decompression command based on format
decompress_cmd=""
case "$image" in
  *.img.xz) decompress_cmd="xzcat" ;;
  *.img.gz) decompress_cmd="zcat" ;;
  *.img)    decompress_cmd="cat" ;;
  *)
    echo "Error: unsupported image format (expected .img, .img.xz, or .img.gz)" >&2
    exit 1
    ;;
esac

# Fixed remote filename avoids shell metacharacter issues with scp/ssh.
# The extension is preserved so the helper knows how to decompress.
case "$image" in
  *.img.xz) remote_image="/dev/shm/flash-image.img.xz" ;;
  *.img.gz) remote_image="/dev/shm/flash-image.img.gz" ;;
  *.img)    remote_image="/dev/shm/flash-image.img" ;;
esac

# Get compressed (on-disk) file size
image_size=$(stat -f%z "$image" 2>/dev/null || stat -c%s "$image" 2>/dev/null || true)
if [ -z "$image_size" ]; then
  echo "Error: could not determine image file size" >&2
  exit 1
fi
image_size_mb=$((image_size / 1048576))

size_label="on-disk"
if [[ "$image" == *.img.xz ]] || [[ "$image" == *.img.gz ]]; then
  size_label="compressed"
fi

# --- Validate customization flags ---

if [ -n "$custom_hostname" ] && ! [[ "$custom_hostname" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$ ]]; then
  echo "Error: hostname must contain only alphanumeric characters and hyphens" >&2
  exit 1
fi
if [ -n "$custom_user" ] && ! [[ "$custom_user" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
  echo "Error: username must be a valid Linux username (lowercase, alphanumeric, hyphens, underscores)" >&2
  exit 1
fi
if [ -n "$wifi_country" ] && ! [[ "$wifi_country" =~ ^[A-Z]{2}$ ]]; then
  echo "Error: wifi-country must be a 2-letter country code (e.g., GB, US, FI)" >&2
  exit 1
fi
if [ -n "$wifi_ssid" ] && [ -z "$wifi_password" ]; then
  echo "Error: wifi-ssid requires wifi-password" >&2
  exit 1
fi
if [ -n "$wifi_password" ] && [ -z "$wifi_ssid" ]; then
  echo "Error: wifi-password requires wifi-ssid" >&2
  exit 1
fi
if [ -n "$custom_password" ] && [ -z "$custom_user" ]; then
  echo "Error: password requires user" >&2
  exit 1
fi

# If user given without explicit ssh-key, auto-detect local SSH public keys
if [ -n "$custom_user" ] && [ ${#custom_ssh_keys[@]} -eq 0 ]; then
  for pubkey in ~/.ssh/*.pub; do
    [ -f "$pubkey" ] && custom_ssh_keys+=("$pubkey")
  done
fi

if [ -n "$custom_user" ] && [ -z "$custom_password" ] && [ ${#custom_ssh_keys[@]} -eq 0 ]; then
  echo "Warning: user set but no password or SSH keys found. User will have no authentication method." >&2
  echo "  Add password or ssh-key to your config file, or place public keys in ~/.ssh/*.pub" >&2
fi

# If password given, hash it locally
password_hash=""
if [ -n "$custom_password" ]; then
  _require openssl
  password_hash=$(printf '%s' "$custom_password" | openssl passwd -6 -stdin)
fi

has_customization=false
if [ -n "$custom_hostname" ] || [ -n "$custom_user" ] || [ -n "$wifi_ssid" ]; then
  has_customization=true
fi

# --- Generate first-boot payloads ---
# Follows the cloudinit-rpi format used by RPi Imager 2.x:
# - user-data: cloud-init YAML with users: block, hostname, ssh_pwauth
# - network-config: netplan YAML with eth0 + optional wlan0

custom_user_data=""
custom_network_config=""

# Build user-data YAML matching RPi Imager's cloudinit-rpi format
ud_lines=()
ud_lines+=("#cloud-config")

if [ -n "$custom_hostname" ]; then
  ud_lines+=("hostname: $custom_hostname")
  ud_lines+=("manage_etc_hosts: true")
fi

if [ -n "$custom_user" ]; then
  # Read SSH public keys
  ssh_key_lines=()
  for keyfile in "${custom_ssh_keys[@]}"; do
    if [ ! -f "$keyfile" ]; then
      echo "Error: SSH key file not found: $keyfile" >&2
      exit 1
    fi
    ssh_key_lines+=("$(head -1 "$keyfile")")
  done

  ud_lines+=("users:")
  ud_lines+=("  - name: $custom_user")
  ud_lines+=("    groups: users,adm,dialout,audio,netdev,video,plugdev,cdrom,games,input,gpio,spi,i2c,render,sudo")
  ud_lines+=("    shell: /bin/bash")
  ud_lines+=("    sudo: ALL=(ALL) NOPASSWD:ALL")
  if [ -n "$password_hash" ]; then
    ud_lines+=("    lock_passwd: false")
    ud_lines+=("    passwd: $password_hash")
  fi
  if [ ${#ssh_key_lines[@]} -gt 0 ]; then
    ud_lines+=("    ssh_authorized_keys:")
    for key in "${ssh_key_lines[@]}"; do
      ud_lines+=("      - $key")
    done
  fi
  ud_lines+=("enable_ssh: true")
  ud_lines+=("ssh_pwauth: true")
fi

# Only produce user-data if there's more than just the #cloud-config header
if [ ${#ud_lines[@]} -gt 1 ]; then
  custom_user_data=$(printf '%s\n' "${ud_lines[@]}")
  # NoCloud datasource requires meta-data to exist (even if minimal)
  custom_meta_data="instance-id: flash-live-remote-$(date +%s)"
fi

if [ -n "$wifi_ssid" ]; then
  # Compute WPA PSK from passphrase + SSID (avoids plaintext password on disk)
  _require python3
  wifi_psk=$(python3 -c "
import hashlib, sys
psk = hashlib.pbkdf2_hmac('sha1', sys.argv[1].encode(), sys.argv[2].encode(), 4096, 32)
print(psk.hex())
" "$wifi_password" "$wifi_ssid")

  # Match RPi Imager's network-config format exactly
  custom_network_config="network:
  version: 2
  ethernets:
    eth0:
      dhcp4: true
      dhcp6: true
      optional: true
  wifis:
    wlan0:
      dhcp4: true
      regulatory-domain: \"$wifi_country\"
      access-points:
        \"$wifi_ssid\":
          password: \"$wifi_psk\"
      optional: true"
fi

# Mode-specific local prerequisites
_require ssh scp
if [ "$mode" = "stream" ]; then
  _require "$decompress_cmd"
fi

# --- Phase 0: Resolve hostname and detect target device ---

echo "=== Phase 0: Resolving hostname and checking target ==="

# Verify busybox is available on target
if ! ssh -n "$host" "command -v busybox" >/dev/null 2>&1; then
  echo "Error: busybox not found on $host (required for flash helper)" >&2
  exit 1
fi

# Detect root block device
root_part=$(ssh -n "$host" "findmnt -no SOURCE /")
if [ -z "$root_part" ]; then
  echo "Error: could not detect root partition" >&2
  exit 1
fi

root_dev=$(ssh -n "$host" "lsblk -ndo PKNAME '$root_part'")
if [ -z "$root_dev" ]; then
  echo "Error: could not determine parent device for $root_part" >&2
  exit 1
fi
root_dev="/dev/$root_dev"

if ! ssh -n "$host" "test -b '$root_dev'"; then
  echo "Error: $root_dev is not a valid block device on $host" >&2
  exit 1
fi

dev_size=$(ssh -n "$host" "lsblk -bno SIZE '$root_dev' | head -1")
dev_size_gb=$((dev_size / 1073741824))

# Mode-specific preflight checks
if [ "$mode" = "ramfs" ]; then
  # Check /dev/shm capacity (trim whitespace from df output)
  shm_avail=$(ssh -n "$host" "df -B1 --output=avail /dev/shm | tail -1 | tr -d ' '")
  shm_avail_mb=$((shm_avail / 1048576))
  margin_bytes=209715200  # 200 MB
  required=$((image_size + margin_bytes))
  if [ "$shm_avail" -lt "$required" ]; then
    echo "Error: insufficient space in /dev/shm on target" >&2
    echo "  Available: ${shm_avail_mb} MB" >&2
    echo "  Required:  $((required / 1048576)) MB (image + 200 MB margin)" >&2
    echo "" >&2
    echo "Try --stream mode for low-memory devices." >&2
    exit 1
  fi
  echo "Target /dev/shm: ${shm_avail_mb} MB available (need ${image_size_mb} MB + margin)"

  # Check decompression tool on target
  if [ "$decompress_cmd" != "cat" ]; then
    if ! ssh -n "$host" "command -v $decompress_cmd" >/dev/null 2>&1; then
      echo "Error: $decompress_cmd not found on $host (required for decompression)" >&2
      exit 1
    fi
  fi
fi

# Preflight checks for customization capabilities on target
if [ "$has_customization" = true ]; then
  echo "Checking customization prerequisites on target..."

  # Verify kernel supports vfat
  if ! ssh -n "$host" "grep -q vfat /proc/filesystems"; then
    echo "Error: kernel on $host lacks vfat support (required for customization)" >&2
    exit 1
  fi

  # Verify busybox has required applets for loop-mount boot partition
  for applet in fdisk losetup; do
    if ! ssh -n "$host" "busybox $applet --help" >/dev/null 2>&1; then
      echo "Error: busybox on $host lacks $applet applet (required for customization)" >&2
      exit 1
    fi
  done
fi

# --- Confirmation prompt ---

echo ""
echo "  Mode: $mode"
echo "  Target device: $root_dev (~${dev_size_gb} GB)"
echo "  Root partition: $root_part"
echo "  Image file: $image (${image_size_mb} MB ${size_label})"
echo "  Target host: $host"
if [ "$has_customization" = true ]; then
  echo ""
  echo "  First-boot customization:"
  [ -n "$custom_hostname" ] && echo "    Hostname: $custom_hostname"
  if [ -n "$custom_user" ]; then
    user_info="$custom_user"
    [ -n "$custom_password" ] && user_info+=" (with password)"
    [ ${#custom_ssh_keys[@]} -gt 0 ] && user_info+=" (with ${#custom_ssh_keys[@]} SSH key(s))"
    echo "    User: $user_info"
  fi
  [ -n "$wifi_ssid" ] && echo "    WiFi: $wifi_ssid (country: $wifi_country)"
fi
echo ""
echo "WARNING: This will ERASE ALL DATA on $root_dev on $host."
echo "The device will be unreachable during flashing and will reboot when done."
echo ""
read -r -p "Type 'yes' to proceed: " confirm
if [ "$confirm" != "yes" ]; then
  echo "Aborted."
  exit 1
fi

# Transfer customization payloads to target (after confirmation to avoid
# leaving sensitive data on target if the user aborts)
if [ "$has_customization" = true ]; then
  echo ""
  echo "Transferring customization payloads..."
  if [ -n "$custom_user_data" ]; then
    echo "$custom_user_data" | ssh "$host" "cat > /dev/shm/custom-user-data"
    echo "$custom_meta_data" | ssh "$host" "cat > /dev/shm/custom-meta-data"
  fi
  if [ -n "$custom_network_config" ]; then
    echo "$custom_network_config" | ssh "$host" "cat > /dev/shm/custom-network-config"
    echo "$wifi_country" | ssh "$host" "cat > /dev/shm/custom-wifi-country"
  fi
fi

# --- Ramfs mode ---

flash_ramfs() {
  echo ""
  echo "=== Phase 1: Copying image to target ==="

  echo "Copying image to /dev/shm on target..."
  scp -O "$image" "$host:$remote_image"

  # Verify file size matches
  remote_size=$(ssh -n "$host" "stat -c%s '$remote_image'")
  if [ "$remote_size" != "$image_size" ]; then
    echo "Error: size mismatch after transfer" >&2
    echo "  Local:  $image_size bytes" >&2
    echo "  Remote: $remote_size bytes" >&2
    echo "Cleaning up remote file..."
    ssh -n "$host" "rm -f '$remote_image'"
    exit 1
  fi
  echo "Transfer verified: $remote_size bytes"

  echo ""
  echo "=== Phase 2: Flashing image ==="

  echo "Stopping services on target..."
  ssh -n "$host" "sudo systemctl stop 'container-*' 'marine-*' 'halos-*' cockpit docker 2>/dev/null || true; sync"

  # Deploy helper script — passes all variable values as arguments to avoid
  # shell metacharacter issues with filenames expanded into the heredoc.
  ssh "$host" "cat > /dev/shm/flash-helper.sh" <<'HELPER_EOF'
#!/bin/bash
set -eo pipefail

IMAGE_PATH="$1"
TARGET_DEV="$2"
DECOMPRESS_CMD="$3"

# Resolve all binary paths now — after dd overwrites the disk, PATH lookups
# against the rootfs may fail (page cache eviction under memory pressure).
BUSYBOX_SRC=$(command -v busybox)
DD=$(command -v dd)
DECOMPRESS=$(command -v "$DECOMPRESS_CMD")

# Copy busybox to tmpfs — after dd, busybox's text pages can be evicted
# from cache and the kernel will try to page them back from the overwritten
# disk, causing SIGBUS. Tmpfs is RAM-backed so pages are never evicted.
cp "$BUSYBOX_SRC" /dev/shm/busybox
chmod +x /dev/shm/busybox
BUSYBOX=/dev/shm/busybox

# Reboot on exit with sysrq fallback — if busybox reboot fails for any
# reason, sysrq-trigger forces an immediate hardware reboot.
trap '"$BUSYBOX" reboot -f 2>/dev/null || { echo 1 > /proc/sys/kernel/sysrq; echo b > /proc/sysrq-trigger; }' EXIT

echo "flash-helper: decompressing and writing $IMAGE_PATH -> $TARGET_DEV"
"$DECOMPRESS" "$IMAGE_PATH" | "$DD" of="$TARGET_DEV" bs=4M 2>/dev/shm/dd-status
echo "flash-helper: dd complete:"
"$BUSYBOX" cat /dev/shm/dd-status 2>/dev/null || true

"$BUSYBOX" rm -f "$IMAGE_PATH"

# Apply first-boot customization if payload files were transferred.
# Errors here must not abort — the image is already flashed successfully,
# so we want to reboot regardless. Run in a subshell to isolate from set -e.
if [ -f /dev/shm/custom-user-data ] || [ -f /dev/shm/custom-network-config ]; then
  (
    echo "flash-helper: applying first-boot customization..."

    # Mount via loop device at the correct offset from the NEW partition table.
    # After dd, the kernel still has stale partition nodes (old offsets/sizes)
    # and stale block cache from the old image. Using the partition node would
    # read/write at the wrong offset or serve cached data. Instead, parse the
    # new partition table directly and create a loop device at the right offset.
    #
    # Busybox fdisk format (CHS columns precede LBA):
    #   /dev/nvme0n1p1 *  128,0,1  1023,3,32  16384  1064959  1048576  512M c ...
    # After stripping the optional boot flag (*), StartLBA is field 4.
    PART1_LINE=$("$BUSYBOX" fdisk -l "$TARGET_DEV" 2>/dev/null \
      | "$BUSYBOX" grep "^${TARGET_DEV}" | "$BUSYBOX" head -1)
    PART1_START=$(echo "$PART1_LINE" | "$BUSYBOX" sed 's/\*//' | "$BUSYBOX" awk '{print $4}')

    # Validate parsed offset — must be a positive integer
    if ! echo "$PART1_START" | "$BUSYBOX" grep -qE '^[0-9]+$' || [ "$PART1_START" -eq 0 ]; then
      echo "flash-helper: ERROR: failed to parse boot partition offset (got: '$PART1_START')"
      exit 1
    fi
    OFFSET=$((PART1_START * 512))

    LOOP_DEV=$("$BUSYBOX" losetup -f)
    "$BUSYBOX" losetup -o "$OFFSET" "$LOOP_DEV" "$TARGET_DEV"

    "$BUSYBOX" mkdir -p /dev/shm/bootmnt
    if "$BUSYBOX" mount -t vfat "$LOOP_DEV" /dev/shm/bootmnt; then
      [ -f /dev/shm/custom-user-data ] && \
        "$BUSYBOX" cp /dev/shm/custom-user-data /dev/shm/bootmnt/user-data
      [ -f /dev/shm/custom-meta-data ] && \
        "$BUSYBOX" cp /dev/shm/custom-meta-data /dev/shm/bootmnt/meta-data
      [ -f /dev/shm/custom-network-config ] && \
        "$BUSYBOX" cp /dev/shm/custom-network-config /dev/shm/bootmnt/network-config
      # Update regulatory domain in cmdline.txt to match WiFi country
      if [ -f /dev/shm/custom-wifi-country ] && [ -f /dev/shm/bootmnt/cmdline.txt ]; then
        REGDOM=$("$BUSYBOX" cat /dev/shm/custom-wifi-country | "$BUSYBOX" tr -d '[:space:]')
        "$BUSYBOX" sed -i "s/cfg80211.ieee80211_regdom=[A-Z]*/cfg80211.ieee80211_regdom=$REGDOM/" /dev/shm/bootmnt/cmdline.txt
      fi
      # umount flushes FAT32 data. No explicit sync — a global sync would risk
      # writing back old rootfs dirty pages over the new image.
      "$BUSYBOX" umount /dev/shm/bootmnt
      echo "flash-helper: boot partition customization applied"
    else
      echo "flash-helper: ERROR: could not mount boot partition for customization"
    fi
    "$BUSYBOX" losetup -d "$LOOP_DEV" 2>/dev/null || true
  ) || echo "flash-helper: WARNING: customization failed, continuing to reboot"
fi

# EXIT trap handles reboot -f (skips sync so old rootfs cache doesn't
# write back over the new image).
echo "flash-helper: rebooting..."
HELPER_EOF

  ssh -n "$host" "chmod +x /dev/shm/flash-helper.sh"

  echo "Launching flash helper on target..."
  ssh -n "$host" "sudo setsid /dev/shm/flash-helper.sh '$remote_image' '$root_dev' '$decompress_cmd' </dev/null >/dev/shm/flash-helper.log 2>&1 &"

  echo ""
  echo "Image is being flashed on the target device."
  echo "The device will reboot automatically when done."
  echo ""
  echo "Wait ~60s then try: ssh $host"
}

# --- Stream mode ---

flash_stream() {
  echo ""
  echo "=== Phase 1: Preparing target ==="

  # Deploy helper script — reads image data from stdin (piped via SSH),
  # writes to block device, then reboots.
  ssh "$host" "cat > /dev/shm/flash-helper.sh" <<'HELPER_EOF'
#!/bin/bash

TARGET_DEV="$1"

# Resolve all binary paths now — after dd overwrites the disk, PATH lookups
# against the rootfs may fail (page cache eviction under memory pressure).
BUSYBOX_SRC=$(command -v busybox)
DD=$(command -v dd)

# Copy busybox to tmpfs (see ramfs helper for rationale).
cp "$BUSYBOX_SRC" /dev/shm/busybox
chmod +x /dev/shm/busybox
BUSYBOX=/dev/shm/busybox

# Reboot when done (or on failure) with sysrq fallback.
trap '"$BUSYBOX" reboot -f 2>/dev/null || { echo 1 > /proc/sys/kernel/sysrq; echo b > /proc/sysrq-trigger; }' EXIT

echo "flash-helper: writing stdin -> $TARGET_DEV"
"$DD" of="$TARGET_DEV" bs=4M 2>/dev/shm/dd-status
"$BUSYBOX" cat /dev/shm/dd-status 2>/dev/null || true
echo "flash-helper: dd complete"

# Apply first-boot customization if payload files were transferred.
# Errors must not prevent reboot. Run in a subshell to isolate failures.
if [ -f /dev/shm/custom-user-data ] || [ -f /dev/shm/custom-network-config ]; then
  (
    echo "flash-helper: applying first-boot customization..."

    # Mount via loop device at correct offset (see ramfs helper for rationale).
    PART1_LINE=$("$BUSYBOX" fdisk -l "$TARGET_DEV" 2>/dev/null \
      | "$BUSYBOX" grep "^${TARGET_DEV}" | "$BUSYBOX" head -1)
    PART1_START=$(echo "$PART1_LINE" | "$BUSYBOX" sed 's/\*//' | "$BUSYBOX" awk '{print $4}')

    # Validate parsed offset — must be a positive integer
    if ! echo "$PART1_START" | "$BUSYBOX" grep -qE '^[0-9]+$' || [ "$PART1_START" -eq 0 ]; then
      echo "flash-helper: ERROR: failed to parse boot partition offset (got: '$PART1_START')"
      exit 1
    fi
    OFFSET=$((PART1_START * 512))

    LOOP_DEV=$("$BUSYBOX" losetup -f)
    "$BUSYBOX" losetup -o "$OFFSET" "$LOOP_DEV" "$TARGET_DEV"

    "$BUSYBOX" mkdir -p /dev/shm/bootmnt
    if "$BUSYBOX" mount -t vfat "$LOOP_DEV" /dev/shm/bootmnt; then
      [ -f /dev/shm/custom-user-data ] && \
        "$BUSYBOX" cp /dev/shm/custom-user-data /dev/shm/bootmnt/user-data
      [ -f /dev/shm/custom-meta-data ] && \
        "$BUSYBOX" cp /dev/shm/custom-meta-data /dev/shm/bootmnt/meta-data
      [ -f /dev/shm/custom-network-config ] && \
        "$BUSYBOX" cp /dev/shm/custom-network-config /dev/shm/bootmnt/network-config
      # Update regulatory domain in cmdline.txt to match WiFi country
      if [ -f /dev/shm/custom-wifi-country ] && [ -f /dev/shm/bootmnt/cmdline.txt ]; then
        REGDOM=$("$BUSYBOX" cat /dev/shm/custom-wifi-country | "$BUSYBOX" tr -d '[:space:]')
        "$BUSYBOX" sed -i "s/cfg80211.ieee80211_regdom=[A-Z]*/cfg80211.ieee80211_regdom=$REGDOM/" /dev/shm/bootmnt/cmdline.txt
      fi
      "$BUSYBOX" umount /dev/shm/bootmnt
      echo "flash-helper: boot partition customization applied"
    else
      echo "flash-helper: ERROR: could not mount boot partition for customization"
    fi
    "$BUSYBOX" losetup -d "$LOOP_DEV" 2>/dev/null || true
  ) || echo "flash-helper: WARNING: customization failed, continuing to reboot"
fi

echo "flash-helper: rebooting..."
HELPER_EOF

  ssh -n "$host" "chmod +x /dev/shm/flash-helper.sh"

  echo "Stopping services on target..."
  ssh -n "$host" "sudo systemctl stop 'container-*' 'marine-*' 'halos-*' cockpit docker 2>/dev/null || true; sync"

  echo ""
  echo "=== Phase 2: Streaming image ==="

  start_time=$(date +%s)

  echo "Streaming image via SSH..."
  # SSH connection drops when the target reboots after dd — that's expected.
  # Disable errexit to capture PIPESTATUS and distinguish decompression
  # failures (real error) from SSH connection drops (expected).
  set +eo pipefail
  # shellcheck disable=SC2029  # $root_dev is intentionally expanded client-side
  "$decompress_cmd" "$image" | ssh "$host" "sudo /dev/shm/flash-helper.sh '$root_dev'"
  decompress_exit=${PIPESTATUS[0]}
  set -eo pipefail

  end_time=$(date +%s)
  elapsed_s=$((end_time - start_time))

  if [ "$decompress_exit" -ne 0 ]; then
    echo ""
    echo "Error: decompression failed (exit code $decompress_exit)." >&2
    echo "The target device may be in an inconsistent state." >&2
    exit 1
  fi

  echo ""
  echo "Transfer complete (${elapsed_s}s)."
  echo "The device will reboot automatically."
  echo ""
  echo "Wait ~60s then try: ssh $host"
}

# --- Dispatch ---

case "$mode" in
  ramfs)  flash_ramfs ;;
  stream) flash_stream ;;
esac
